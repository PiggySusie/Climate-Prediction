<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>PM2.5 çƒ­åŠ›å›¾åŠ¨ç”»ï¼ˆé¢„æµ‹ & è¯¯å·®ï¼‰</title>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; margin: 20px; }
    #chart { width: 85vw; height: 70vh; margin: auto; }
    #controls { margin-top: 20px; }
    button { padding: 6px 12px; font-size: 14px; margin: 4px; }
    #timeline { width: 85vw; margin: 10px auto; }
    #time-display { display: inline-block; width: 120px; text-align: right; margin-right: 10px; }
    .time-indicator { display: inline-block; width: 80px; text-align: center; }
  </style>
</head>
<body>

  <h2>ğŸ” PM2.5 å¤šç«™ç‚¹é¢„æµ‹çƒ­åŠ›å›¾ï¼ˆConvLSTMï¼‰</h2>
  <div id="chart"></div>
  <div id="controls">
    <button onclick="play()">â–¶ æ’­æ”¾</button>
    <button onclick="pause()">â¸ æš‚åœ</button>
    <button onclick="toggleMode()">ğŸ” åˆ‡æ¢æ¨¡å¼</button>
    <div id="time-controls">
      <div id="time-display">æ—¶é—´ç‚¹:</div>
      <input type="range" id="timeline" min="0" max="100" value="0">
      <div class="time-indicator" id="time-index">0</div>
      <div class="time-indicator" id="time-total">0</div>
    </div>
    <br>
    <input type="text" id="time-input" placeholder="ä¾‹å¦‚ 2015-03-01 15:00">
    <button onclick="predictTime()">ğŸ“¥ é¢„æµ‹æŒ‡å®šæ—¶é—´</button>
    <div id="status">Time: -, Mode: predicted</div>
  </div>

  <script>
    const chart = echarts.init(document.getElementById('chart'));
    let timer = null;
    let currentIndex = 0;
    let frames = [];
    let mode = "predicted";  // æˆ– "error"
    let timeIndices = []; // å­˜å‚¨æ—¶é—´ç´¢å¼•å¯¹åº”çš„å®é™…æ—¶é—´

    const stationGrid = [
      ["æ€€æŸ”", "é¡ºä¹‰", "æ˜Œå¹³", "å®šé™µ"],
      ["ä¸‡æŸ³", "å¤åŸ", "å¥¥ä½“ä¸­å¿ƒ", "ä¸œå››"],
      ["å®˜å›­", "ä¸‡å¯¿è¥¿å®«", "å¤©å›", "å†œå±•é¦†"]
    ];

    fetch("data/pm25_prediction_vs_truth_mult.json")
      .then(res => res.json())
      .then(raw => {
        const grouped = groupByTime(raw);
        frames = grouped;
        timeIndices = grouped.map((_, i) => i); // ç®€å•ç¤ºä¾‹ï¼Œå®é™…åº”æ˜ å°„åˆ°çœŸå®æ—¶é—´
        updateTimeline();
        drawFrame(currentIndex);
      });

    function groupByTime(data) {
      const grouped = {};
      data.forEach(d => {
        if (!grouped[d.time_index]) grouped[d.time_index] = [];
        grouped[d.time_index].push(d);
      });
      return Object.values(grouped);  // æŒ‰æ—¶é—´é¡ºåºæ•°ç»„
    }

    function drawFrame(index) {
      if (!frames[index]) return;

      currentIndex = index;
      updateTimelineValue(index);

      const data = frames[index];
      const values = Array(3).fill(0).map(() => Array(4).fill(0));

      data.forEach(d => {
        const val = mode === "predicted" ? d.predicted_pm25 : d.error;
        values[d.row][d.col] = val;
      });

      chart.setOption({
        title: {
          text: `æ—¶é—´ç‚¹: ${index} (${mode === 'predicted' ? 'é¢„æµ‹å€¼ Î¼g/mÂ³' : 'é¢„æµ‹è¯¯å·®'})`
        },
        tooltip: {
          trigger: 'item',
          formatter: function (params) {
            const r = params.value[1];
            const c = params.value[0];
            const station = stationGrid[r][c];
            return `${station}<br>${mode === 'predicted' ? 'é¢„æµ‹ PM2.5' : 'è¯¯å·®'}: ${params.value[2].toFixed(1)} Î¼g/mÂ³`;
          }
        },
        xAxis: {
          type: 'category',
          data: [0, 1, 2, 3],
          name: 'åˆ—'
        },
        yAxis: {
          type: 'category',
          data: [0, 1, 2],
          name: 'è¡Œ',
          inverse: true
        },
        visualMap: {
          min: mode === "predicted" ? 0 : -50,
          max: mode === "predicted" ? 200 : 50,
          calculable: true,
          orient: 'horizontal',
          left: 'center',
          bottom: '5%',
          text: ['é«˜', 'ä½']
        },
        series: [{
          type: 'heatmap',
          name: 'PM2.5',
          data: formatToSeries(values),
          label: {
            show: true,
            formatter: function (params) {
              const row = params.value[1];
              const col = params.value[0];
              const station = stationGrid[row][col];
              const val = params.value[2].toFixed(1);
              return `${station}\n\n${val}`;  // å¢åŠ ç©ºè¡Œæé«˜å¯è¯»æ€§
            },
            fontSize: 14,
            color: '#000'
          },
          emphasis: {
            itemStyle: {
              shadowBlur: 10,
              shadowColor: 'rgba(0,0,0,0.5)'
            }
          }
        }]
      });

      document.getElementById("status").innerText =
        `æ—¶é—´: ${index} / ${frames.length}   æ¨¡å¼: ${mode}`;
    }

    function formatToSeries(arr2d) {
      const res = [];
      for (let i = 0; i < arr2d.length; i++) {
        for (let j = 0; j < arr2d[0].length; j++) {
          res.push([j, i, arr2d[i][j]]);
        }
      }
      return res;
    }

    function play() {
      if (timer) return;
      timer = setInterval(() => {
        currentIndex = (currentIndex + 1) % frames.length;
        drawFrame(currentIndex);
      }, 1000);
    }

    function pause() {
      clearInterval(timer);
      timer = null;
    }

    function toggleMode() {
      mode = (mode === "predicted") ? "error" : "predicted";
      drawFrame(currentIndex);
    }

    function updateTimeline() {
      const timeline = document.getElementById('timeline');
      const timeTotal = document.getElementById('time-total');
      if (frames.length > 0) {
        timeline.max = frames.length - 1;
        timeline.value = currentIndex;
        timeTotal.textContent = frames.length - 1;
      }
    }

    function updateTimelineValue(index) {
      const timeline = document.getElementById('timeline');
      timeline.value = index;
      document.getElementById('time-index').textContent = index;
    }

    // è¿›åº¦æ¡äº‹ä»¶ç›‘å¬
    document.getElementById('timeline').addEventListener('input', function() {
      const index = parseInt(this.value);
      drawFrame(index);
      pause(); // æ‹–åŠ¨è¿›åº¦æ¡æ—¶æš‚åœè‡ªåŠ¨æ’­æ”¾
    });

    let validTimes = [];

    window.onload = function () {
      fetch("/valid_times")
        .then(res => res.json())
        .then(times => {
          validTimes = times;
        });
    };

    function predictTime() {
      const input = document.getElementById("time-input").value.trim();
      if (!input) {
        alert("è¯·è¾“å…¥ä¸€ä¸ªæ—¶é—´ï¼Œä¾‹å¦‚ï¼š2015-06-01 15:00");
        return;
      }

      if (!validTimes.includes(input)) {
        alert("è¯¥æ—¶é—´ä¸å¯é¢„æµ‹ï¼Œè¯·è¾“å…¥ä¸€ä¸ªå¯ç”¨æ—¶é—´(20130301-20170228)");
        return;
      }

      fetch(`/predict?time=${encodeURIComponent(input)}`)
        .then(res => {
          if (!res.ok) throw new Error(`è¯·æ±‚å¤±è´¥: ${res.status}`);
          return res.json();
        })
        .then(result => {
          const values = result.grid;
          if (!values || values.flat().every(v => isNaN(v))) {
            alert("è¯¥æ—¶é—´ç‚¹æ— æœ‰æ•ˆé¢„æµ‹æ•°æ®ï¼");
            return;
          }

          chart.setOption({
            title: { text: `é¢„æµ‹ PM2.5 â€” ${input}` },
            tooltip: {
              trigger: 'item',
              formatter: function (params) {
                const r = params.value[1];
                const c = params.value[0];
                const station = stationGrid[r][c];
                return `${station}<br>PM2.5: ${params.value[2].toFixed(1)} Î¼g/mÂ³`;
              }
            },
            visualMap: {
              min: 0,
              max: 200,
              calculable: true,
              orient: 'horizontal',
              left: 'center',
              bottom: '5%',
              text: ['é«˜', 'ä½']
            },
            series: [{
              type: 'heatmap',
              data: formatToSeries(values),
              label: {
                show: true,
                formatter: function (params) {
                  const row = params.value[1];
                  const col = params.value[0];
                  const station = stationGrid[row][col];
                  const val = params.value[2].toFixed(1);
                  return `${station}\n\n${val}`;
                }
              }
            }]
          });

          document.getElementById("status").innerText =
            `æ—¶é—´: ${input}   æ¨¡å¼: predicted`;

          pause(); // åœæ­¢æ’­æ”¾
        })
        .catch(error => {
          alert("è¯·æ±‚å¤±è´¥ï¼š" + error.message);
          console.error(error);
        });
    }
  </script>
</body>
</html>